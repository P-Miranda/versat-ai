
addressGen DataSimple(xWidth,yWidth,zWidth,aWidth,bWidth,cWidth){
   for c 0..cWidth
   for b 0..bWidth
   for a 0..aWidth
   for z 0..zWidth
   for y 0..yWidth
   for x 0..xWidth
   addr = ((((c * bWidth + b) * aWidth + a) * zWidth + z) * yWidth + y) * xWidth + x;
}

addressGen DataBroadCasted(cEnable,cLoop,bEnable,bLoop,cWidth,aEnable,aLoop,bWidth,zEnable,zLoop,aWidth,yEnable,yLoop,zWidth,xEnable,xLoop,yWidth){
   for c 0..cLoop
   for b 0..bLoop
   for a 0..aLoop
   for z 0..zLoop
   for y 0..yLoop
   for x 0..xLoop
   addr = ((((c * cEnable * cWidth + b * bEnable) * bWidth + a * aEnable) * aWidth + z * zEnable) * zWidth + y * yEnable) * yWidth + x * xEnable;
}

addressGen Linear(size){
   for x 0..size
   addr = x;
}

module Top_Add(){
   using(DataBroadCasted) VRead inputs[2];
   using(DataSimple) VWrite output;
   F_Add adder;
#
   inputs[0..1] -> adder:0..1;
   adder -> output;
}

module Top_Relu(){
   using(Linear) VRead input;
   using(Linear) VWrite output;
   Relu relu;
#
   input -> relu;
   relu -> output;   
}

// Output space
addressGen Linear2(startX,startY,startOffset,sizeW,sizeH,outputImageW,stride){
   for y 0..sizeH
   for x 0..sizeW
   addr = ((y + startY) * outputImageW + (x + startX) + startOffset) / stride;
}

// Should be Input space but I think some values in here are output space
addressGen MaxPool2D(startX,startY,startOffset,kernelW,kernelH,imageWidth,sizeW,sizeH,strideW,strideH){
   for y  0..sizeH
   for x  0..sizeW
   for ky 0..kernelH
   for kx 0..kernelW
   addr = startOffset + (y * strideH + startY + ky) * imageWidth + x * strideW + startX + kx;
}

module Top_Maxpool(){
   using(MaxPool2D) VRead features;
   F_AccumMax accum;
   using(Linear2) VWrite output;
#   
   features -> accum;
   accum -> output;
}

module Top_Conv(){
   using(Linear2) VRead features;
   using(Linear2) VRead weights;
   using(Linear2) VRead bias;
   F_Mul muller;
   F_Add addBias;
   MyFloatAccum myAccum;
   using(Linear2) VWrite output;
#   
   {weights,features} -> muller:0..1;
   muller -> myAccum;
   {myAccum,bias} -> addBias:0..1;

   addBias -> output;
}

merge Test = Top_Add | Top_Relu | Top_Maxpool | Top_Conv;
