
addressGen DataSimple(xWidth,yWidth,zWidth,aWidth,bWidth,cWidth){
   for c 0..cWidth
   for b 0..bWidth
   for a 0..aWidth
   for z 0..zWidth
   for y 0..yWidth
   for x 0..xWidth
   addr = ((((c * bWidth + b) * aWidth + a) * zWidth + z) * yWidth + y) * xWidth + x;
}

addressGen DataBroadCasted(cEnable,cLoop,bEnable,bLoop,cWidth,aEnable,aLoop,bWidth,zEnable,zLoop,aWidth,yEnable,yLoop,zWidth,xEnable,xLoop,yWidth){
   for c 0..cLoop
   for b 0..bLoop
   for a 0..aLoop
   for z 0..zLoop
   for y 0..yLoop
   for x 0..xLoop
   addr = ((((c * cEnable * cWidth + b * bEnable) * bWidth + a * aEnable) * aWidth + z * zEnable) * zWidth + y * yEnable) * yWidth + x * xEnable;
}

addressGen Linear(size){
   for x 0..size
   addr = x;
}

module Top_Add(){
   using(DataBroadCasted) VRead inputs[2];
   using(DataSimple) VWrite output;
   F_Add adder;
#
   inputs[0..1] -> adder:0..1;
   adder -> output;
}

module Top_Relu(){
   using(Linear) VRead input;
   using(Linear) VWrite output;
   Relu relu;
#
   input -> relu;
   relu -> output;   
}

// Output space
addressGen Linear2(startX,startY,startOffset,sizeW,sizeH,outputImageW,stride){
   for y 0..sizeH
   for x 0..sizeW
   addr = ((y + startY) * outputImageW + (x + startX) + startOffset) / stride;
}

// Should be Input space but I think some values in here are output space
addressGen MaxPool2D(startX,startY,startOffset,kernelW,kernelH,imageWidth,sizeW,sizeH,strideW,strideH){
   for y  0..sizeH
   for x  0..sizeW
   for ky 0..kernelH
   for kx 0..kernelW
   addr = startOffset + (y * strideH + startY + ky) * imageWidth + x * strideW + startX + kx;
}

module Top_Maxpool(){
   using(MaxPool2D) VRead features;
   F_AccumMax accum;
   using(Linear2) VWrite output;
#   
   features -> accum;
   accum -> output;
}

addressGen Conv2D_NHWC(startX,startY,sizeW,sizeH,inputImageW,inputImageC,features){
   for d 0..features
   for c 0..inputImageC
   for ky 0..sizeH
   for kx 0..sizeW
   addr = (startY + ky) * inputImageW * inputImageC + (startX + kx) * inputImageC + c;
}

addressGen Weight2D(startX,startY,sizeW,sizeH,kernelW,kernelH,inputChannels,features){
   for c 0..features
   for d 0..inputChannels
   for y 0..sizeH
   for x 0..sizeW
   addr = c * inputChannels * kernelW * kernelH + d * kernelW * kernelH + (y + startY) * kernelW + (x + startX);
}

addressGen Linear2_NHWC(startX,startY,height,width,startC,outputChannels,outputWidth,stride){
   for y 0..height
   for x 0..width
   for c 0..outputChannels
   addr = ((y + startY) * outputWidth * outputChannels + (x + startX) * outputChannels + startC + c) / stride;
}

module Top_Conv(){
   using(Conv2D_NHWC) VRead features;
   using(Weight2D) VRead weights;
   // using(Linear2) VRead bias;
   F_Mul muller;
   // F_Add addBias;
   MyFloatAccum myAccum;
   using(Linear2_NHWC) VWrite output;
#   
   {weights,features} -> muller:0..1;
   muller -> myAccum;
      
   myAccum -> output;

   //{myAccum,bias} -> addBias:0..1;
   //addBias -> output;
}

merge Test = Top_Add | Top_Relu | Top_Maxpool | Top_Conv;
